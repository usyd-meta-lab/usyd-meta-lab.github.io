<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kit Double | Publications</title>
  <style>
    /* logo in the top-right corner, subtle styling */
    .logo-float {
      float: right;
      max-width: 100px;
      margin: 0 0 1rem 1rem;
      filter: grayscale(30%) brightness(110%)
              drop-shadow(0 2px 4px rgba(0,0,0,0.15));
    }

    body {
      font-family: Georgia, serif;
      max-width: 900px;
      margin: 2rem auto;
      padding: 0 1rem;
    }
    h2 { font-size: 2em; border-bottom: 2px solid #ccc; padding-bottom: 0.5rem; }
    h3 { margin-top: 2rem; color: #333; }
    ol { padding-left: 1.5em; }
    li { margin-bottom: 1.2em; line-height: 1.5; }
    a  { color: #0077cc; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>

<a href="/" title="Back to main site">
  <img src="images/logo.PNG" alt="USYD Meta Lab Logo" class="logo-float">
</a>

<section id="publications">
  <h2>Publications</h2>
  <div id="pub-container">Loading publications…</div>
</section>

<script>
  const orcidId = '0000-0001-8120-1573';

  /* ---------- Helper functions ---------- */
  async function fetchSummary() {
    const res = await fetch(`https://pub.orcid.org/v3.0/${orcidId}/works`, {
      headers: { Accept: 'application/json' }
    });
    const data = await res.json();
    return data.group.map(g => g['work-summary'][0]);
  }

  async function fetchFullRecord(putCode) {
    const res = await fetch(`https://pub.orcid.org/v3.0/${orcidId}/work/${putCode}`, {
      headers: { Accept: 'application/json' }
    });
    return await res.json();
  }

  /* Strip “: Behaviour, Psychology and …”-type subsections that follow a colon */
  function cleanTitle(raw) {
    if (!raw) return raw;
    return raw.replace(/: [A-Z][A-Za-z0-9 ,&--]{2,60}$/, '');
  }

  function formatAPAAuthors(contributors) {
    if (!contributors || contributors.length === 0) return 'Unknown Author';

    const names = contributors.map(c => {
      const structured = c['contributor-name'];
      const fallback   = c['credit-name']?.value;

      // structured fields preferred
      if (structured && structured['family-name'] && structured['given-names']) {
        const last = structured['family-name'].value;
        const initials = structured['given-names'].value
          .split(/\s+/)
          .map(n => n[0].toUpperCase() + '.')
          .join(' ');
        return `${last}, ${initials}`;
      }

      // fallback parsing
      if (fallback) {
        const cleaned = fallback.trim();
        if (cleaned.includes(',')) {
          const [last, rest] = cleaned.split(',');
          const initials = rest.trim().split(/\s+/).map(n => n[0].toUpperCase() + '.').join(' ');
          return `${last.trim()}, ${initials}`;
        }
        const parts = cleaned.split(/\s+/);
        if (parts.length >= 2) {
          const last = parts.pop();
          const initials = parts.map(n => n[0].toUpperCase() + '.').join(' ');
          return `${last}, ${initials}`;
        }
        return cleaned;
      }

      return 'Unknown';
    });

    if (names.length > 7) return `${names[0]} et al.`;
    if (names.length === 1) return names[0];
    if (names.length === 2) return `${names[0]} & ${names[1]}`;
    return names.slice(0, -1).join(', ') + ', & ' + names[names.length - 1];
  }

  /* ---------- Main load function ---------- */
  async function loadPublications() {
    try {
      // 1. summaries → full records
      const summaries = await fetchSummary();
      const detailed  = await Promise.all(
        summaries.map(s => fetchFullRecord(s['put-code']))
      );

      // 2. keep only journal articles + clean titles
      const parsed = detailed
        .filter(pub => pub.type === 'journal-article' || pub.type === 'JOURNAL_ARTICLE')
        .map(pub => {
          const title   = cleanTitle(pub.title?.title?.value) || 'Untitled';
          const year    = pub['publication-date']?.year?.value || 'No Year';
          const authors = formatAPAAuthors(pub.contributors?.contributor || []);
          const doiObj  = (pub['external-ids']?.['external-id'] || [])
                           .find(id => id['external-id-type'] === 'doi');
          const doi     = doiObj ? doiObj['external-id-value'] : null;
          const journal = pub['journal-title']?.value || '';
          return { title, year, authors, doi, journal };
        });

      // 3. group by year
      const grouped = {};
      parsed.forEach(p => {
        if (!grouped[p.year]) grouped[p.year] = [];
        grouped[p.year].push(p);
      });

      // 4. render with global descending numbers (oldest = 1)
      const container = document.getElementById('pub-container');
      container.innerHTML = '';
      const years = Object.keys(grouped).sort((a, b) => b - a);

      const totalCount = parsed.length;
      let counter = totalCount;

      years.forEach(year => {
        const yearDiv = document.createElement('div');
        yearDiv.innerHTML = `<h3>${year}</h3>`;

        const ol = document.createElement('ol');
        ol.setAttribute('start', counter);
        ol.setAttribute('reversed', '');

        grouped[year].forEach(pub => {
          const li = document.createElement('li');
          let ref  = `${pub.authors} (${pub.year}). <strong>${pub.title}</strong>`;
          if (pub.journal) ref += `. <em>${pub.journal}</em>`;
          if (pub.doi) ref += `. <a href="https://doi.org/${pub.doi}" target="_blank">https://doi.org/${pub.doi}</a>`;
          ref += '.';
          li.innerHTML = ref;
          ol.appendChild(li);
        });

        counter -= grouped[year].length;
        yearDiv.appendChild(ol);
        container.appendChild(yearDiv);
      });

    } catch (err) {
      document.getElementById('pub-container').textContent = 'Failed to load publications.';
      console.error(err);
    }
  }

  loadPublications();
</script>

</body>
</html>